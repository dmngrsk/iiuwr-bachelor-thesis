\chapter{Proces budowy zapytania}
Znając sposób działania dostawców LINQ oraz budowę drzewa \texttt{QueryModel}, wystarczy opracować metodę przechodzenia przez te drzewa w celu budowy zapytania do bazy PostgreSQL. Punktem wejściowym dla projektu, który jest załącznikiem do niniejszej pracy, jest artykuł \cite{codeproject_nhibernate}, opisujący przykładową implementację dostawcy LINQ dla NHibernate.

\section{Implementacja \texttt{QueryModelVisitorBase}}
Korzystając z dotychczasowej wiedzy, następnym krokiem do wykonania jest implementacja metod odwiedzających nowe drzewo rozbioru składniowego. Również w tym przypadku biblioteka re-linq asystuje programistę w tym zadaniu, udostępniając klasę \href{https://github.com/re-motion/Relinq/blob/ab11f0997998a90e17e90dc58b215c3997d47311/Core/QueryModelVisitorBase.cs}{\texttt{QueryModelVisitorBase}}, która implementuje zbiór metod odwiedzających obiekt \texttt{QueryModel}. Klasa ta nie robi nic szczególnego, poza sprawdzeniem poprawności typu elementów przekazywanych w argumentach oraz ich zaakceptowaniu - typowa implementacja wzorca Odwiedzający (Visitor). Trzeba oczywiście napisać rozszerzenie tej klasy, która wykona dodatkową logikę na argumentach implementowanych metod, oraz wywoła bazową logikę z użyciem słowa kluczowego \texttt{base}.

Argumentami każdej z metod, które będą nadpisywane, są różne klauzule - skondensowane do postaci wygodnych obiektów - które występują w zapytaniu LINQ. Ich właściwościami są znane już obiekty \texttt{Expression}, jednak są one na tyle proste, że można łatwo się zająć ich odwiedzeniem, i o tym będzie traktować następna sekcja tego rozdziału. Na chwilę obecną załóżmy, że posiadamy generyczną metodę, która odwiedza każdy możliwy podtyp \texttt{Expression}, i na jego podstawie buduje fragment zapytania SQL-owego, który jest przekazywany do instancji klasy \texttt{QueryPartsAggregator}, służącej do łączenia takich fragmentów w pełne zapytanie SQL. Dokładna implementacja klasy, która jest tematem niniejszego podrozdziału, znajduje się w pliku \texttt{PsqlGeneratingQueryModelVisitor.cs}. Autor pracy zachęca czytelnika do zapoznawania się z nim w trakcie czytania następnych podsekcji.

\subsection{Metoda \texttt{VisitQueryModel}}
TODO.

\subsection{Metoda \texttt{VisitSelectClause}}
TODO.

\subsection{Metoda \texttt{VisitMainFromClause}}
TODO.

\subsection{Metoda \texttt{VisitWhereClause}}
TODO.

\subsection{Metoda \texttt{VisitOrderByClause}}
TODO.

\subsection{Metoda \texttt{VisitJoinClause}}
TODO.

\subsection{Metoda \texttt{VisitAdditionalFromClause}}
TODO.

\subsection{Metoda \texttt{VisitGroupJoinClause}}
TODO.

\subsection{Metoda \texttt{VisitResultOperator}}
TODO.

\section{Implementacja \texttt{RelinqExpressionVisitor}}
TODO.

\subsection{Metoda \texttt{VisitBinary}}
TODO.

\section{Czynności następujące budowę zapytania}
Potrafiąc zbudować dowolne zapytanie SQL-owe na podstawie zapytania LINQ, pozostaje już tylko kwestia wykonania go i zwrócenia wyniku w postaci obiektowej. Autor pracy postanowił użyć do tego celu bibliotek \href{}{Npgsql} (połączenie z bazą PostgreSQL, wykonywanie zapytania) oraz \href{}{Dapper} (rozszerzenie umożliwiające wygodne mapowanie relacyjno-obiektowe).

Z użyciem tych dwóch bibliotek, wykonanie zapytania i przetłumaczenie wyniku do postaci obiektowej jest bardzo proste - biblioteka Dapper rozszerza obiekt \texttt{NpgsqlConnection} służący do łączenia z bazą danych o metody \texttt{Query} i \texttt{Query<T>}, które umożliwiają automatyczne mapowanie wyniku do postaci obiektowej. Poniżej fragment kodu z przykładowej implementacji \texttt{IQueryExecutor}:

\begin{lstlisting}
var commandData = SomeQueryModelVisitor.GenerateQuery(queryModel);

var s = commandData.Statement;
var p = commandData.Parameters;

return connection.Query<SomeClass>(s, p);
\end{lstlisting}

W tym miejscu zmienna \texttt{result} jest typu \texttt{IEnumerable<SomeClass>}, gdzie \texttt{SomeClass} jest typem obiektu, który zwraca oryginalne zapytanie LINQ (jest ono typu \texttt{IQueryable<SomeClass>)}. Dapper wymaga, aby nazwy kolumn w relacjach mapowanych na obiekty były takie same, jak nazwy właściwości w klasie modelowej - stąd, podczas budowy zapytania, każda kolumna została przemianowana na nazwę odpowiadającej właściwości w klasie z użyciem słowa kluczowego \texttt{AS}.

Autorowi pracy niestety nie udało się dotrzeć do tego, w jaki sposób Dapper może mapować krotki na typy anonimowe, lecz znalazł obejście tego problemu. Algorytm składa się z następujących kroków:

\begin{enumerate}
\item Sprawdź, czy typ obiektu wyjściowego jest anonimowy. Jeśli nie, wykonaj metodę \texttt{Query<T>} i zwróć wynik.
\item Wiadomo, że typ obiektu jest anonimowy. Wykonaj metodę \texttt{Query}, która zwraca wynik w postaci obiektów \texttt{DapperRow}. 
\item Przetłumacz DapperRow na słownik \texttt{IDictionary}.
\item Wyciągnij tylko i wyłącznie wartości każ Wewnętrzna implementacja \texttt{DapperRow} gwarantuje, że kolejność wartości z par kluczy-wartość będzie zgodna z kolejnością kolumn w wynikowym zapytania.
\item Korzystając z klasy \texttt{Activator}, dla każdej krotki stwórz instancję typu \texttt{T}, której wartościami będzie krotka przekazywana jako argument do metody \texttt{Activator.CreateInstance}. Zwróć wynik.
\end{enumerate}

W ten sposób, implementacja \texttt{IQueryExecutor} jest w stanie przemapować \textit{prawie} każde zapytanie do postaci obiektowej. Trzeba jednak jeszcze rozpatrzyć przypadek, gdzie zapytanie LINQ wykorzystywało metodę \texttt{GroupBy}. TODO.