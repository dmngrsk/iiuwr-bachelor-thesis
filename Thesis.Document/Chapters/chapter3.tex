\chapter{Testy jakości i wydajności}
Niniejsza sekcja jest krótkim raportem o możliwościach dostarczanych przez dostawcę LINQ implementowanego w ramach tej pracy dyplomowej oraz jego wydajności czasowej, porównanej z innymi rozwiązaniami dostępnymi na rynku.

\section{Dostępne funkcjonalności}
Autor niniejszej pracy podczas realizowania projektu używał techniki \textit{test-driven development}, tj. przed implementacją pewnej funkcjonalności napisał test, który ją pokrywa. Wszystkie testy są dostępne w katalogu \texttt{Thesis.Relinq.Tests}.

Biorąc pod uwagę wszystkie testy, które zostały napisane, zaimplementowanymi funkcjonalnościami są:

\begin{itemize}
\setlength\itemsep{0em}
\item Połączenie się z bazą danych.
\item Obsługa podstawowych operatorów binarnych (dodawanie, logiczny OR, itp.).
\item Obsługa funkcji agregujących (Sum, Average, Min, Max, Count, Distinct).
\item Obsługa funkcji na napisach.
\item Budowa zapytania zwracającego kolekcję obiektów modelowych.
\item Budowa zapytania zwracającego kolekcję obiektów anonimowych.
\item Możliwość dodania jednego lub więcej wyrażenia warunkowego do zapytania.
\item Możliwość dodania wyniku rozwinięcia drzewa warunkowego do zapytania \linebreak (\texttt{CASE WHEN ... THEN ... END}).
\item Obsługa zapytań z wyrażeniem \texttt{EXISTS}.
\item Możliwość dodania porządkowania wyniku zapytania.
\item Możliwość stronicowania wyniku zapytania.
\item Możliwość łączenia kilku źródeł danych za pomocą złączeń wewnętrznych \linebreak (\textit{inner join}), zewnętrznych obustronnych (\textit{cross join}), zewnętrznych jednostronnych (\textit{outer left/right join}).
\item Możliwość wykonania C\#-owego \texttt{GroupJoin} na tabelach w PostgreSQL,
\item Obsługa operatorów działających na zbiorach (\texttt{UNION, UNION ALL, \linebreak INTERSECT, EXCEPT}).
\item Parametryzacja zapytań w celu zwiększenia bezpieczeństwa.
\end{itemize}

Funkcjonalnościami, które są ważne, lecz niestety nie zostały zaimplementowane z powodu ich trudności, są:

\begin{itemize}
\item Grupowanie z funkcją agregującą z użyciem \texttt{GROUP BY} - C\#-owa metoda \texttt{GroupBy} działa w inny sposób, niż funkcja \texttt{GROUP BY} w zapytaniach SQL-owych. W odróżnieniu od SQL-a, grupowanie w C\# może przebiegać nie tylko po funkcjach agregujących, takich jak \texttt{COUNT()} lub \texttt{AVG()}, ale również po właściwościach, czy nawet całych obiektach.
\item C\#-owe metody \href{https://msdn.microsoft.com/pl-pl/library/bb534804(v=vs.110).aspx}{\texttt{TakeWhile}} i \href{https://www.google.pl/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwj43ai66LPUAhVCVhQKHSm4BfkQFggnMAA&url=https%3A%2F%2Fmsdn.microsoft.com%2Fpl-pl%2Flibrary%2Fbb549075(v%3Dvs.110).aspx&usg=AFQjCNHEbD9WVhCdEeCDPQw0CIt845i9Kg&sig2=41OZNQAxqA1IYG9QzuzK1g}{\texttt{SkipWhile}} - ze względu na brak możliwości napisania zapytania SQL-owego odpowiadającemu tym metodom bez wykorzystania procedur składowanych (ang. \textit{stored procedures}), implementacja takiej funkcjonalności jest prawdopodobnie niemożliwa; w tymi metodami nie radzi sobie żaden ORM (nawet Entity Framework), który jest znany autorowi pracy.
\item Automatyczne wyznaczanie kontekstu z bazy danych - istnieje konieczność ręcznej budowy klas i ich właściwości, które mają odpowiadać tabelom i ich kolumnom w bazie danych, do której pisane jest zapytanie. Dobrym rozwiązaniem na nadanie swobody nazwy takiej klasy i jej właściwości byłoby przydzielanie im własnych atrybutów, tak jak realizowane jest to w bibliotece LINQ to DB, której przyjrzymy się w ramach testów wydajnościowych w następnej sekcji.
\end{itemize}

\section{Wydajność a inne rozwiązania}
Z poprzedniej sekcji wynika, że przeciętny student informatyki w ciągu czterech miesięcy jest w stanie napisać w ramach pracy dyplomowej dostawcę LINQ z nietrywialnymi funkcjonalnościami. Czas sprawdzić wydajność takiego dostawcy, porównując go z komercyjnym LinqConnect firmy DevArt, dołączonym do próbnej wersji biblioteki \href{https://www.devart.com/dotconnect/postgresql/}{dotConnect for PostgreSQL 7.9 Professional}, oraz open-sourcowym \href{https://github.com/linq2db/linq2db}{LINQ to DB}, które jest rozwijane od kilku lat. W celu sprawdzenia wydajności tych trzech dostawców LINQ dla PostgreSQL, użyta została biblioteka do testowania wydajności w .NET o nazwie \href{https://github.com/dotnet/BenchmarkDotNet}{BenchmarkDotNet}.

W ramach sprawiedliwego pomiaru, każda z trzech bibliotek otrzymała identyczne zapytania do wykonania na tej samej bazie danych. Poniższa tabela przedstawia czasy wykonania pojedynczego zapytania określonego rodzaju (nazwy testów powinny mówić same za siebie):

\vspace{0.2in}
\begin{table}[h]
\centering
\begin{tabular}{l|ccc}
\textbf{Nazwa testu}                    & \textbf{LinqConnect} & \textbf{linq2db} & \textbf{ThesisRelinq} \\
\hline
select\_all                             & 0,877 ms             & 1,443 ms          & 4,888 ms             \\
select\_anonymous\_type                 & 0,658 ms             & 0,569 ms          & 4,226 ms             \\
select\_with\_where                     & 0,594 ms             & 0,362 ms          & 3,874 ms             \\
select\_with\_multiconditional\_where   & 0,682 ms             & 0,488 ms          & 4,518 ms             \\
select\_with\_multiple\_wheres          & 0,703 ms             & 0,498 ms          & 4,399 ms             \\
select\_with\_case                      & 0,659 ms             & N/A               & 4,034 ms             \\
select\_with\_orderings\_joined         & 0,721 ms             & 0,637 ms          & 4,594 ms             \\
select\_with\_orderings\_split          & 0,719 ms             & 0,630 ms          & 4,559 ms             \\
select\_with\_take\_while               & N/A                  & N/A               & N/A                  \\
select\_with\_cross\_join               & 2,873 ms             & 3,169 ms          & 11,570 ms            \\
select\_with\_inner\_join               & 2,945 ms             & 3,544 ms          & 11,229 ms            \\
select\_with\_group\_join               & 69,715 ms            & 74,779 ms         & 155,695 ms           \\
select\_with\_outer\_join               & 3,036 ms             & 3,682 ms          & 10,984 ms            \\
select\_with\_paging                    & 1,129 ms             & 0,444 ms          & 4,477 ms             \\
select\_where\_any\_matches\_condition  & 1,820 ms             & 1,996 ms          & 8,493 ms             \\
select\_where\_all\_match\_condition    & 1,416 ms             & 0,900 ms          & 7,224 ms             \\
select\_with\_union                     & 0,890 ms             & N/A               & 4,565 ms             \\
select\_with\_concat\_as\_union\_all    & 0,842 ms             & N/A               & 4,228 ms             \\
select\_with\_intersect                 & 1,012 ms             & 1,229 ms          & 5,039 ms             \\
select\_with\_except                    & 1,025 ms             & 0,683 ms          & 5,070 ms    
\end{tabular}
\end{table}

\vspace{0.1in}
Zakładając, że pierwsze dwie biblioteki działają w optymalnym czasie, można zauważyć, że dostawca LINQ autora pracy działa około pięć razy wolniej od rozwiązania wzorcowego.